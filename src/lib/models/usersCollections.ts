import { createClient } from "@/lib/utils/supabase/client";
export type user_role = 'owner' | 'buyer' | 'collaborator';

/**
 * Data model for a collection-user relationship.
 * 'id' is optional for creation, as it may be auto-generated by the database.
 */
export interface UsersCollectionsData {
    id?: string;
    collection_id: string;
    user_id: string;
    favorite?: boolean;
    user_role?: user_role;
}

class UsersCollections {
    /**
     * Create a new collection-user link.
     * @param usersCollections - The data for the new link
     * @returns The created UsersCollectionsData object
     */
    static async create(usersCollections: UsersCollectionsData): Promise<UsersCollectionsData> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .insert(usersCollections)
                .select()
                .single();

            if (error) {
                throw new Error(`Error creating reference: ${error.message}`);
            }
            return data as UsersCollectionsData;
        } catch (error) {
            console.error("Error creating collection-prompt link:", error);
            throw error;
        }
    }



        /**
     * Get all collections for a user.
     * @param userId - The prompt's ID
     * @returns Array of collection IDs (empty if none found)
     */
    static async getCollections(userId: string): Promise<string[]> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('collection_id')
                .eq('user_id', userId);

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return [];
                } 
                throw new Error(`Error getting users for collection: ${error.message}`);
            }

            if (!data) return [];
            return data.map(row => row.collection_id);
        } catch (error) {
            console.error("Error getting users by collection ID:", error);
            throw error;
        }
    }


    /**
     * Get all user ID in a collection.
     * @param collectionId - The collection's ID
     * @returns Array of prompt IDs (empty if none found)
     */
    static async getUsers(collectionId: string): Promise<string[]> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('user_id')
                .eq('collection_id', collectionId);

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return [];
                } 
                throw new Error(`Error getting prompts for collection: ${error.message}`);
            }

            if (!data) return [];
            return data.map(row => row.user_id);
        } catch (error) {
            console.error("Error getting prompts by collection ID:", error);
            throw error;
        }
    }

    /**
     * Get the role of a user in a collection.
     * @param userID - The collection's ID
     * @param collectiionId - The collections's ID
     * @returns Array of prompt IDs (empty if none found)
     */
    static async getUserRole(collectionId: string, userId: string): Promise<user_role | null> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('user_role')
                .eq('user_id', userId)
                .eq('collection_id', collectionId)
                .single();

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return null;
                } 
                throw new Error(`Error getting prompts for collection: ${error.message}`);
            }

            if (!data) return null;
            return data.user_role;
        } catch (error) {
            console.error("Error getting prompts by collection ID:", error);
            throw error;
        }
    }

    /**
     * Get all favorite collectionsfor a user.
     * @param userId - The users's ID
     * @returns Array of collection IDs (empty if none found)
     */
    static async getFavorites(userId: string): Promise<string[]> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('collection_id')
                .eq('user_id', userId)
                .eq('favorite', true);

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return [];
                }
                throw new Error(`Error getting collections for prompt: ${error.message}`);
            }

            if (!data) return [];
            return data.map(row => row.collection_id);
        } catch (error) {
            console.error("Error getting collections for prompt:", error);
            throw error;
        }
    }

    /**
     * Get all collection IDs for a user.
     * @param userId - The users's ID
     * @returns Array of collection IDs (empty if none found)
     */
    static async isFavorite(userId: string, collectionId: string): Promise<boolean> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('favorite')
                .eq('user_id', userId)
                .eq('collection_id', collectionId)
                .single();

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return false;
                }
                throw new Error(`Error getting collections for prompt: ${error.message}`);
            }

            if (!data) return false;
            return !!data.favorite;
        } catch (error) {
            console.error("Error getting collections for prompt:", error);
            throw error;
        }
    }

    /**
     * update the role of a user in a collection.
     * @param collectionId - The collection's ID
     * @param role - The new role for the user
     * @param userId - The users's ID
     * @returns The updated UsersCollectionsData object
     */
    static async updateRole(collectionId: string, userId: string, role: user_role): Promise<UsersCollectionsData> {
        try {
            const supabase = await createClient();

            const { data, error } = await supabase
                .from('users_collections')
                .update({ user_role: role })
                .eq('collection_id', collectionId)
                .eq('user_id', userId)
                .select()
                .single();

            if (error) {
                throw new Error(`Error updating collection: ${error.message}`);
            }

            return data as UsersCollectionsData;
        } catch (error) {
            console.error("Error updating collection:", error);
            throw error;
        }
    }
    

    /**
     * update the favorite in a collection for a user.
     * @param collectionId - The collection's ID
     * @param userId - The users's ID
     * @param fav - The new favorite status
     * @returns The updated UsersCollectionsData object
     */
    static async updateFavorite(collectionId: string, userId: string, fav: boolean): Promise<UsersCollectionsData> {
        try {
            const supabase = await createClient();

            const { data, error } = await supabase
                .from('users_collections')
                .update({favorite: fav})
                .eq('collection_id', collectionId)
                .eq('user_id', userId)
                .select()
                .single();

            if (error) {
                throw new Error(`Error updating collection: ${error.message}`);
            }

            return data as UsersCollectionsData;
        } catch (error) {
            console.error("Error updating collection:", error);
            throw error;
        }
    }

    /**
     * Remove the link between a prompt and a collection.
     * @param promptId - The prompt's ID
     * @param collectionId - The collection's ID
     */
    static async delete(userId: string, collectionId: string): Promise<void> {
        try {
            const supabase = await createClient();
    
            const { error } = await supabase
                .from('users_collections')
                .delete()
                .eq('user_id', userId)
                .eq('collection_id', collectionId);

            if (error) {
                throw new Error(`Error removing prompt from collection: ${error.message}`);
            }
        } catch (error) {
            console.error("Error removing prompt from collection:", error);
            throw error;
        }
    }

    /**
     * Get the number of users in a collection.
     * @param collectionId - The collection's ID
     * @returns The count of users
     */
    static async getUserCount(collectionId: string): Promise<number> {
        try {
            const supabase = await createClient();
            const { count, error } = await supabase
                .from('users_collections')
                .select('*', { count: 'exact', head: true })
                .eq('collection_id', collectionId);

            if (error) {
                throw new Error(`Error getting user count: ${error.message}`);
            }
            return count || 0;
        } catch (error) {
            console.error("Error getting user count:", error); 
            throw error;
        }
    }

    /**
     * Get the number of collections a user has.
     * @param userId - The users's ID
     * @returns The count of collections
     */
    static async getCollectionCount(userId: string): Promise<number> {
        try {
            const supabase = await createClient();
            const { count, error } = await supabase
                .from('users_collections')
                .select('collection_id', { count: 'exact', head: true })
                .eq('user_id', userId);

            if (error) {
                throw new Error(`Error getting collection count: ${error.message}`);
            }
            return count || 0;
        } catch (error) {
            console.error("Error getting collection count:", error);
            throw error;
        }
    }

    /**
     * Get all user-collection relationships for a user with roles in one batch query.
     * @param userId - The user's ID
     * @returns Object containing collections, favorites, and roles mappings
     */
    static async getUserRelationships(userId: string): Promise<{
        collections: string[],
        favorites: string[],
        roles: Record<string, user_role>
    }> {
        try {
            const supabase = await createClient();
            const { data, error } = await supabase
                .from('users_collections')
                .select('collection_id, favorite, user_role')
                .eq('user_id', userId);

            if (error) {
                if (error.code === 'PGRST116') { // No rows returned
                    return { collections: [], favorites: [], roles: {} };
                }
                throw new Error(`Error getting user collection relationships: ${error.message}`);
            }

            if (!data) return { collections: [], favorites: [], roles: {} };

            const collections: string[] = [];
            const favorites: string[] = [];
            const roles: Record<string, user_role> = {};

            for (const row of data) {
                collections.push(row.collection_id);
                if (row.favorite) {
                    favorites.push(row.collection_id);
                }
                if (row.user_role) {
                    roles[row.collection_id] = row.user_role;
                }
            }

            return { collections, favorites, roles };
        } catch (error) {
            console.error("Error getting user collection relationships:", error);
            throw error;
        }
    }
}

export default UsersCollections;